//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: jar:file:jsoup-1.8.3-fis-sources.jar!org/jsoup/parser/Tokeniser.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Character.h"
#include "java/lang/Integer.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/StringBuilder.h"
#include "java/util/Arrays.h"
#include "org/jsoup/helper/Validate.h"
#include "org/jsoup/nodes/Entities.h"
#include "org/jsoup/parser/CharacterReader.h"
#include "org/jsoup/parser/ParseError.h"
#include "org/jsoup/parser/ParseErrorList.h"
#include "org/jsoup/parser/Token.h"
#include "org/jsoup/parser/Tokeniser.h"
#include "org/jsoup/parser/TokeniserState.h"

@interface OrgJsoupParserTokeniser () {
 @public
  OrgJsoupParserCharacterReader *reader_;
  OrgJsoupParserParseErrorList *errors_;
  OrgJsoupParserTokeniserState *state_;
  OrgJsoupParserToken *emitPending_;
  jboolean isEmitPending_;
  NSString *charsString_;
  JavaLangStringBuilder *charsBuilder_;
  NSString *lastStartTag_;
  jboolean selfClosingFlagAcknowledged_;
  IOSCharArray *charRefHolder_;
}

- (void)characterReferenceErrorWithNSString:(NSString *)message;

- (void)errorWithNSString:(NSString *)errorMsg;

@end

J2OBJC_FIELD_SETTER(OrgJsoupParserTokeniser, reader_, OrgJsoupParserCharacterReader *)
J2OBJC_FIELD_SETTER(OrgJsoupParserTokeniser, errors_, OrgJsoupParserParseErrorList *)
J2OBJC_FIELD_SETTER(OrgJsoupParserTokeniser, state_, OrgJsoupParserTokeniserState *)
J2OBJC_FIELD_SETTER(OrgJsoupParserTokeniser, emitPending_, OrgJsoupParserToken *)
J2OBJC_FIELD_SETTER(OrgJsoupParserTokeniser, charsString_, NSString *)
J2OBJC_FIELD_SETTER(OrgJsoupParserTokeniser, charsBuilder_, JavaLangStringBuilder *)
J2OBJC_FIELD_SETTER(OrgJsoupParserTokeniser, lastStartTag_, NSString *)
J2OBJC_FIELD_SETTER(OrgJsoupParserTokeniser, charRefHolder_, IOSCharArray *)

inline IOSCharArray *OrgJsoupParserTokeniser_get_notCharRefCharsSorted(void);
static IOSCharArray *OrgJsoupParserTokeniser_notCharRefCharsSorted;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgJsoupParserTokeniser, notCharRefCharsSorted, IOSCharArray *)

__attribute__((unused)) static void OrgJsoupParserTokeniser_characterReferenceErrorWithNSString_(OrgJsoupParserTokeniser *self, NSString *message);

__attribute__((unused)) static void OrgJsoupParserTokeniser_errorWithNSString_(OrgJsoupParserTokeniser *self, NSString *errorMsg);

J2OBJC_INITIALIZED_DEFN(OrgJsoupParserTokeniser)

@implementation OrgJsoupParserTokeniser

- (instancetype)initWithOrgJsoupParserCharacterReader:(OrgJsoupParserCharacterReader *)reader
                     withOrgJsoupParserParseErrorList:(OrgJsoupParserParseErrorList *)errors {
  OrgJsoupParserTokeniser_initWithOrgJsoupParserCharacterReader_withOrgJsoupParserParseErrorList_(self, reader, errors);
  return self;
}

- (OrgJsoupParserToken *)read {
  if (!selfClosingFlagAcknowledged_) {
    OrgJsoupParserTokeniser_errorWithNSString_(self, @"Self closing flag not acknowledged");
    selfClosingFlagAcknowledged_ = true;
  }
  while (!isEmitPending_) [((OrgJsoupParserTokeniserState *) nil_chk(state_)) readWithOrgJsoupParserTokeniser:self withOrgJsoupParserCharacterReader:reader_];
  if ([((JavaLangStringBuilder *) nil_chk(charsBuilder_)) java_length] > 0) {
    NSString *str = [((JavaLangStringBuilder *) nil_chk(charsBuilder_)) description];
    (void) [((JavaLangStringBuilder *) nil_chk(charsBuilder_)) delete__WithInt:0 withInt:[charsBuilder_ java_length]];
    charsString_ = nil;
    return [((OrgJsoupParserToken_Character *) nil_chk(charPending_)) dataWithNSString:str];
  }
  else if (charsString_ != nil) {
    OrgJsoupParserToken *token = [((OrgJsoupParserToken_Character *) nil_chk(charPending_)) dataWithNSString:charsString_];
    charsString_ = nil;
    return token;
  }
  else {
    isEmitPending_ = false;
    return emitPending_;
  }
}

- (void)emitWithOrgJsoupParserToken:(OrgJsoupParserToken *)token {
  OrgJsoupHelperValidate_isFalseWithBoolean_withNSString_(isEmitPending_, @"There is an unread token pending!");
  emitPending_ = token;
  isEmitPending_ = true;
  if (((OrgJsoupParserToken *) nil_chk(token))->type_ == JreLoadEnum(OrgJsoupParserToken_TokenType, StartTag)) {
    OrgJsoupParserToken_StartTag *startTag = (OrgJsoupParserToken_StartTag *) cast_chk(token, [OrgJsoupParserToken_StartTag class]);
    lastStartTag_ = startTag->tagName_;
    if (startTag->selfClosing_) selfClosingFlagAcknowledged_ = false;
  }
  else if (token->type_ == JreLoadEnum(OrgJsoupParserToken_TokenType, EndTag)) {
    OrgJsoupParserToken_EndTag *endTag = (OrgJsoupParserToken_EndTag *) cast_chk(token, [OrgJsoupParserToken_EndTag class]);
    if (endTag->attributes_ != nil) OrgJsoupParserTokeniser_errorWithNSString_(self, @"Attributes incorrectly present on end tag");
  }
}

- (void)emitWithNSString:(NSString *)str {
  if (charsString_ == nil) {
    charsString_ = str;
  }
  else {
    if ([((JavaLangStringBuilder *) nil_chk(charsBuilder_)) java_length] == 0) {
      (void) [((JavaLangStringBuilder *) nil_chk(charsBuilder_)) appendWithNSString:charsString_];
    }
    (void) [((JavaLangStringBuilder *) nil_chk(charsBuilder_)) appendWithNSString:str];
  }
}

- (void)emitWithCharArray:(IOSCharArray *)chars {
  [self emitWithNSString:NSString_java_valueOfChars_(chars)];
}

- (void)emitWithChar:(jchar)c {
  [self emitWithNSString:NSString_java_valueOfChar_(c)];
}

- (OrgJsoupParserTokeniserState *)getState {
  return state_;
}

- (void)transitionWithOrgJsoupParserTokeniserState:(OrgJsoupParserTokeniserState *)state {
  self->state_ = state;
}

- (void)advanceTransitionWithOrgJsoupParserTokeniserState:(OrgJsoupParserTokeniserState *)state {
  [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) advance];
  self->state_ = state;
}

- (void)acknowledgeSelfClosingFlag {
  selfClosingFlagAcknowledged_ = true;
}

- (IOSCharArray *)consumeCharacterReferenceWithJavaLangCharacter:(JavaLangCharacter *)additionalAllowedCharacter
                                                     withBoolean:(jboolean)inAttribute {
  if ([((OrgJsoupParserCharacterReader *) nil_chk(reader_)) isEmpty]) return nil;
  if (additionalAllowedCharacter != nil && [additionalAllowedCharacter charValue] == [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) current]) return nil;
  if ([((OrgJsoupParserCharacterReader *) nil_chk(reader_)) matchesAnySortedWithCharArray:OrgJsoupParserTokeniser_notCharRefCharsSorted]) return nil;
  IOSCharArray *charRef = charRefHolder_;
  [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) mark];
  if ([((OrgJsoupParserCharacterReader *) nil_chk(reader_)) matchConsumeWithNSString:@"#"]) {
    jboolean isHexMode = [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) matchConsumeIgnoreCaseWithNSString:@"X"];
    NSString *numRef = isHexMode ? [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) consumeHexSequence] : [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) consumeDigitSequence];
    if ([numRef java_length] == 0) {
      OrgJsoupParserTokeniser_characterReferenceErrorWithNSString_(self, @"numeric reference with no numerals");
      [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) rewindToMark];
      return nil;
    }
    if (![((OrgJsoupParserCharacterReader *) nil_chk(reader_)) matchConsumeWithNSString:@";"]) OrgJsoupParserTokeniser_characterReferenceErrorWithNSString_(self, @"missing semicolon");
    jint charval = -1;
    @try {
      jint base = isHexMode ? 16 : 10;
      charval = [((JavaLangInteger *) nil_chk(JavaLangInteger_valueOfWithNSString_withInt_(numRef, base))) intValue];
    }
    @catch (JavaLangNumberFormatException *e) {
    }
    if (charval == -1 || (charval >= (jint) 0xD800 && charval <= (jint) 0xDFFF) || charval > (jint) 0x10FFFF) {
      OrgJsoupParserTokeniser_characterReferenceErrorWithNSString_(self, @"character outside of valid range");
      *IOSCharArray_GetRef(nil_chk(charRef), 0) = OrgJsoupParserTokeniser_replacementChar;
      return charRef;
    }
    else {
      if (charval < JavaLangCharacter_MIN_SUPPLEMENTARY_CODE_POINT) {
        *IOSCharArray_GetRef(nil_chk(charRef), 0) = (jchar) charval;
        return charRef;
      }
      else return JavaLangCharacter_toCharsWithInt_(charval);
    }
  }
  else {
    NSString *nameRef = [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) consumeLetterThenDigitSequence];
    jboolean looksLegit = [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) matchesWithChar:';'];
    jboolean found = (OrgJsoupNodesEntities_isBaseNamedEntityWithNSString_(nameRef) || (OrgJsoupNodesEntities_isNamedEntityWithNSString_(nameRef) && looksLegit));
    if (!found) {
      [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) rewindToMark];
      if (looksLegit) OrgJsoupParserTokeniser_characterReferenceErrorWithNSString_(self, NSString_java_formatWithNSString_withNSObjectArray_(@"invalid named referenece '%s'", [IOSObjectArray newArrayWithObjects:(id[]){ nameRef } count:1 type:NSObject_class_()]));
      return nil;
    }
    if (inAttribute && ([((OrgJsoupParserCharacterReader *) nil_chk(reader_)) matchesLetter] || [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) matchesDigit] || [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) matchesAnyWithCharArray:[IOSCharArray newArrayWithChars:(jchar[]){ '=', '-', '_' } count:3]])) {
      [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) rewindToMark];
      return nil;
    }
    if (![((OrgJsoupParserCharacterReader *) nil_chk(reader_)) matchConsumeWithNSString:@";"]) OrgJsoupParserTokeniser_characterReferenceErrorWithNSString_(self, @"missing semicolon");
    *IOSCharArray_GetRef(nil_chk(charRef), 0) = [((JavaLangCharacter *) nil_chk(OrgJsoupNodesEntities_getCharacterByNameWithNSString_(nameRef))) charValue];
    return charRef;
  }
}

- (OrgJsoupParserToken_Tag *)createTagPendingWithBoolean:(jboolean)start {
  tagPending_ = start ? [((OrgJsoupParserToken_StartTag *) nil_chk(startPending_)) reset] : [((OrgJsoupParserToken_EndTag *) nil_chk(endPending_)) reset];
  return tagPending_;
}

- (void)emitTagPending {
  [((OrgJsoupParserToken_Tag *) nil_chk(tagPending_)) finaliseTag];
  [self emitWithOrgJsoupParserToken:tagPending_];
}

- (void)createCommentPending {
  (void) [((OrgJsoupParserToken_Comment *) nil_chk(commentPending_)) reset];
}

- (void)emitCommentPending {
  [self emitWithOrgJsoupParserToken:commentPending_];
}

- (void)createDoctypePending {
  (void) [((OrgJsoupParserToken_Doctype *) nil_chk(doctypePending_)) reset];
}

- (void)emitDoctypePending {
  [self emitWithOrgJsoupParserToken:doctypePending_];
}

- (void)createTempBuffer {
  OrgJsoupParserToken_resetWithJavaLangStringBuilder_(dataBuffer_);
}

- (jboolean)isAppropriateEndTagToken {
  return lastStartTag_ != nil && [((NSString *) nil_chk(((OrgJsoupParserToken_Tag *) nil_chk(tagPending_))->tagName_)) isEqual:lastStartTag_];
}

- (NSString *)appropriateEndTagName {
  if (lastStartTag_ == nil) return nil;
  return lastStartTag_;
}

- (void)errorWithOrgJsoupParserTokeniserState:(OrgJsoupParserTokeniserState *)state {
  if ([((OrgJsoupParserParseErrorList *) nil_chk(errors_)) canAddError]) [((OrgJsoupParserParseErrorList *) nil_chk(errors_)) addWithId:new_OrgJsoupParserParseError_initWithInt_withNSString_withNSObjectArray_([((OrgJsoupParserCharacterReader *) nil_chk(reader_)) pos], @"Unexpected character '%s' in input state [%s]", [IOSObjectArray newArrayWithObjects:(id[]){ JavaLangCharacter_valueOfWithChar_([((OrgJsoupParserCharacterReader *) nil_chk(reader_)) current]), state } count:2 type:NSObject_class_()])];
}

- (void)eofErrorWithOrgJsoupParserTokeniserState:(OrgJsoupParserTokeniserState *)state {
  if ([((OrgJsoupParserParseErrorList *) nil_chk(errors_)) canAddError]) [((OrgJsoupParserParseErrorList *) nil_chk(errors_)) addWithId:new_OrgJsoupParserParseError_initWithInt_withNSString_withNSObjectArray_([((OrgJsoupParserCharacterReader *) nil_chk(reader_)) pos], @"Unexpectedly reached end of file (EOF) in input state [%s]", [IOSObjectArray newArrayWithObjects:(id[]){ state } count:1 type:NSObject_class_()])];
}

- (void)characterReferenceErrorWithNSString:(NSString *)message {
  OrgJsoupParserTokeniser_characterReferenceErrorWithNSString_(self, message);
}

- (void)errorWithNSString:(NSString *)errorMsg {
  OrgJsoupParserTokeniser_errorWithNSString_(self, errorMsg);
}

- (jboolean)currentNodeInHtmlNS {
  return true;
}

- (NSString *)unescapeEntitiesWithBoolean:(jboolean)inAttribute {
  JavaLangStringBuilder *builder = new_JavaLangStringBuilder_init();
  while (![((OrgJsoupParserCharacterReader *) nil_chk(reader_)) isEmpty]) {
    (void) [builder appendWithNSString:[((OrgJsoupParserCharacterReader *) nil_chk(reader_)) consumeToWithChar:'&']];
    if ([((OrgJsoupParserCharacterReader *) nil_chk(reader_)) matchesWithChar:'&']) {
      [((OrgJsoupParserCharacterReader *) nil_chk(reader_)) consume];
      IOSCharArray *c = [self consumeCharacterReferenceWithJavaLangCharacter:nil withBoolean:inAttribute];
      if (c == nil || c->size_ == 0) (void) [builder appendWithChar:'&'];
      else (void) [builder appendWithCharArray:c];
    }
  }
  return [builder description];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LOrgJsoupParserToken;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 1, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 1, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 1, 5, -1, -1, -1, -1 },
    { NULL, "LOrgJsoupParserTokeniserState;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 8, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "[C", 0x0, 9, 10, -1, -1, -1, -1 },
    { NULL, "LOrgJsoupParserToken_Tag;", 0x0, 11, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 13, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 14, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 15, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 13, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, 16, 12, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgJsoupParserCharacterReader:withOrgJsoupParserParseErrorList:);
  methods[1].selector = @selector(read);
  methods[2].selector = @selector(emitWithOrgJsoupParserToken:);
  methods[3].selector = @selector(emitWithNSString:);
  methods[4].selector = @selector(emitWithCharArray:);
  methods[5].selector = @selector(emitWithChar:);
  methods[6].selector = @selector(getState);
  methods[7].selector = @selector(transitionWithOrgJsoupParserTokeniserState:);
  methods[8].selector = @selector(advanceTransitionWithOrgJsoupParserTokeniserState:);
  methods[9].selector = @selector(acknowledgeSelfClosingFlag);
  methods[10].selector = @selector(consumeCharacterReferenceWithJavaLangCharacter:withBoolean:);
  methods[11].selector = @selector(createTagPendingWithBoolean:);
  methods[12].selector = @selector(emitTagPending);
  methods[13].selector = @selector(createCommentPending);
  methods[14].selector = @selector(emitCommentPending);
  methods[15].selector = @selector(createDoctypePending);
  methods[16].selector = @selector(emitDoctypePending);
  methods[17].selector = @selector(createTempBuffer);
  methods[18].selector = @selector(isAppropriateEndTagToken);
  methods[19].selector = @selector(appropriateEndTagName);
  methods[20].selector = @selector(errorWithOrgJsoupParserTokeniserState:);
  methods[21].selector = @selector(eofErrorWithOrgJsoupParserTokeniserState:);
  methods[22].selector = @selector(characterReferenceErrorWithNSString:);
  methods[23].selector = @selector(errorWithNSString:);
  methods[24].selector = @selector(currentNodeInHtmlNS);
  methods[25].selector = @selector(unescapeEntitiesWithBoolean:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "replacementChar", "C", .constantValue.asUnichar = OrgJsoupParserTokeniser_replacementChar, 0x18, -1, -1, -1, -1 },
    { "notCharRefCharsSorted", "[C", .constantValue.asLong = 0, 0x1a, -1, 17, -1, -1 },
    { "reader_", "LOrgJsoupParserCharacterReader;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "errors_", "LOrgJsoupParserParseErrorList;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "state_", "LOrgJsoupParserTokeniserState;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "emitPending_", "LOrgJsoupParserToken;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "isEmitPending_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "charsString_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "charsBuilder_", "LJavaLangStringBuilder;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "dataBuffer_", "LJavaLangStringBuilder;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "tagPending_", "LOrgJsoupParserToken_Tag;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "startPending_", "LOrgJsoupParserToken_StartTag;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "endPending_", "LOrgJsoupParserToken_EndTag;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "charPending_", "LOrgJsoupParserToken_Character;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "doctypePending_", "LOrgJsoupParserToken_Doctype;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "commentPending_", "LOrgJsoupParserToken_Comment;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "lastStartTag_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "selfClosingFlagAcknowledged_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "charRefHolder_", "[C", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgJsoupParserCharacterReader;LOrgJsoupParserParseErrorList;", "emit", "LOrgJsoupParserToken;", "LNSString;", "[C", "C", "transition", "LOrgJsoupParserTokeniserState;", "advanceTransition", "consumeCharacterReference", "LJavaLangCharacter;Z", "createTagPending", "Z", "error", "eofError", "characterReferenceError", "unescapeEntities", &OrgJsoupParserTokeniser_notCharRefCharsSorted };
  static const J2ObjcClassInfo _OrgJsoupParserTokeniser = { "Tokeniser", "org.jsoup.parser", ptrTable, methods, fields, 7, 0x10, 26, 19, -1, -1, -1, -1, -1 };
  return &_OrgJsoupParserTokeniser;
}

+ (void)initialize {
  if (self == [OrgJsoupParserTokeniser class]) {
    OrgJsoupParserTokeniser_notCharRefCharsSorted = [IOSCharArray newArrayWithChars:(jchar[]){ 0x0009, 0x000a, 0x000d, 0x000c, ' ', '<', '&' } count:7];
    {
      JavaUtilArrays_sortWithCharArray_(OrgJsoupParserTokeniser_notCharRefCharsSorted);
    }
    J2OBJC_SET_INITIALIZED(OrgJsoupParserTokeniser)
  }
}

@end

void OrgJsoupParserTokeniser_initWithOrgJsoupParserCharacterReader_withOrgJsoupParserParseErrorList_(OrgJsoupParserTokeniser *self, OrgJsoupParserCharacterReader *reader, OrgJsoupParserParseErrorList *errors) {
  NSObject_init(self);
  self->state_ = JreLoadEnum(OrgJsoupParserTokeniserState, Data);
  self->isEmitPending_ = false;
  self->charsString_ = nil;
  self->charsBuilder_ = new_JavaLangStringBuilder_initWithInt_(1024);
  self->dataBuffer_ = new_JavaLangStringBuilder_initWithInt_(1024);
  self->startPending_ = new_OrgJsoupParserToken_StartTag_init();
  self->endPending_ = new_OrgJsoupParserToken_EndTag_init();
  self->charPending_ = new_OrgJsoupParserToken_Character_init();
  self->doctypePending_ = new_OrgJsoupParserToken_Doctype_init();
  self->commentPending_ = new_OrgJsoupParserToken_Comment_init();
  self->selfClosingFlagAcknowledged_ = true;
  self->charRefHolder_ = [IOSCharArray newArrayWithLength:1];
  self->reader_ = reader;
  self->errors_ = errors;
}

OrgJsoupParserTokeniser *new_OrgJsoupParserTokeniser_initWithOrgJsoupParserCharacterReader_withOrgJsoupParserParseErrorList_(OrgJsoupParserCharacterReader *reader, OrgJsoupParserParseErrorList *errors) {
  J2OBJC_NEW_IMPL(OrgJsoupParserTokeniser, initWithOrgJsoupParserCharacterReader_withOrgJsoupParserParseErrorList_, reader, errors)
}

OrgJsoupParserTokeniser *create_OrgJsoupParserTokeniser_initWithOrgJsoupParserCharacterReader_withOrgJsoupParserParseErrorList_(OrgJsoupParserCharacterReader *reader, OrgJsoupParserParseErrorList *errors) {
  J2OBJC_CREATE_IMPL(OrgJsoupParserTokeniser, initWithOrgJsoupParserCharacterReader_withOrgJsoupParserParseErrorList_, reader, errors)
}

void OrgJsoupParserTokeniser_characterReferenceErrorWithNSString_(OrgJsoupParserTokeniser *self, NSString *message) {
  if ([((OrgJsoupParserParseErrorList *) nil_chk(self->errors_)) canAddError]) [((OrgJsoupParserParseErrorList *) nil_chk(self->errors_)) addWithId:new_OrgJsoupParserParseError_initWithInt_withNSString_withNSObjectArray_([((OrgJsoupParserCharacterReader *) nil_chk(self->reader_)) pos], @"Invalid character reference: %s", [IOSObjectArray newArrayWithObjects:(id[]){ message } count:1 type:NSObject_class_()])];
}

void OrgJsoupParserTokeniser_errorWithNSString_(OrgJsoupParserTokeniser *self, NSString *errorMsg) {
  if ([((OrgJsoupParserParseErrorList *) nil_chk(self->errors_)) canAddError]) [((OrgJsoupParserParseErrorList *) nil_chk(self->errors_)) addWithId:new_OrgJsoupParserParseError_initWithInt_withNSString_([((OrgJsoupParserCharacterReader *) nil_chk(self->reader_)) pos], errorMsg)];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgJsoupParserTokeniser)
