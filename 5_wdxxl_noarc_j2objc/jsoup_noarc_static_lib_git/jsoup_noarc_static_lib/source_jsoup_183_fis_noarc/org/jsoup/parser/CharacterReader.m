//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: jar:file:jsoup-1.8.3-fis-sources.jar!org/jsoup/parser/CharacterReader.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/CharSequence.h"
#include "java/lang/Character.h"
#include "java/util/Arrays.h"
#include "java/util/Locale.h"
#include "org/jsoup/helper/Validate.h"
#include "org/jsoup/parser/CharacterReader.h"
#include "org/jsoup/parser/TokeniserState.h"

@interface OrgJsoupParserCharacterReader () {
 @public
  IOSCharArray *input_;
  jint length_;
  jint pos_;
  jint mark_;
  IOSObjectArray *stringCache_;
}

- (NSString *)cacheStringWithInt:(jint)start
                         withInt:(jint)count;

@end

J2OBJC_FIELD_SETTER(OrgJsoupParserCharacterReader, input_, IOSCharArray *)
J2OBJC_FIELD_SETTER(OrgJsoupParserCharacterReader, stringCache_, IOSObjectArray *)

inline jint OrgJsoupParserCharacterReader_get_maxCacheLen(void);
#define OrgJsoupParserCharacterReader_maxCacheLen 12
J2OBJC_STATIC_FIELD_CONSTANT(OrgJsoupParserCharacterReader, maxCacheLen, jint)

__attribute__((unused)) static NSString *OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(OrgJsoupParserCharacterReader *self, jint start, jint count);

@implementation OrgJsoupParserCharacterReader

- (instancetype)initWithNSString:(NSString *)input {
  OrgJsoupParserCharacterReader_initWithNSString_(self, input);
  return self;
}

- (jint)pos {
  return pos_;
}

- (jboolean)isEmpty {
  return pos_ >= length_;
}

- (jchar)current {
  return pos_ >= length_ ? OrgJsoupParserCharacterReader_EOF : IOSCharArray_Get(nil_chk(input_), pos_);
}

- (jchar)consume {
  jchar val = pos_ >= length_ ? OrgJsoupParserCharacterReader_EOF : IOSCharArray_Get(nil_chk(input_), pos_);
  pos_++;
  return val;
}

- (void)unconsume {
  pos_--;
}

- (void)advance {
  pos_++;
}

- (void)mark {
  mark_ = pos_;
}

- (void)rewindToMark {
  pos_ = mark_;
}

- (NSString *)consumeAsString {
  return [NSString java_stringWithCharacters:input_ offset:pos_++ length:1];
}

- (jint)nextIndexOfWithChar:(jchar)c {
  for (jint i = pos_; i < length_; i++) {
    if (c == IOSCharArray_Get(nil_chk(input_), i)) return i - pos_;
  }
  return -1;
}

- (jint)nextIndexOfWithJavaLangCharSequence:(id<JavaLangCharSequence>)seq {
  jchar startChar = [((id<JavaLangCharSequence>) nil_chk(seq)) charAtWithInt:0];
  for (jint offset = pos_; offset < length_; offset++) {
    if (startChar != IOSCharArray_Get(nil_chk(input_), offset)) while (++offset < length_ && startChar != IOSCharArray_Get(input_, offset)) {
    }
    jint i = offset + 1;
    jint last = i + [seq java_length] - 1;
    if (offset < length_ && last <= length_) {
      for (jint j = 1; i < last && [seq charAtWithInt:j] == IOSCharArray_Get(input_, i); i++, j++) {
      }
      if (i == last) return offset - pos_;
    }
  }
  return -1;
}

- (NSString *)consumeToWithChar:(jchar)c {
  jint offset = [self nextIndexOfWithChar:c];
  if (offset != -1) {
    NSString *consumed = OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, pos_, offset);
    pos_ += offset;
    return consumed;
  }
  else {
    return [self consumeToEnd];
  }
}

- (NSString *)consumeToWithNSString:(NSString *)seq {
  jint offset = [self nextIndexOfWithJavaLangCharSequence:seq];
  if (offset != -1) {
    NSString *consumed = OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, pos_, offset);
    pos_ += offset;
    return consumed;
  }
  else {
    return [self consumeToEnd];
  }
}

- (NSString *)consumeToAnyWithCharArray:(IOSCharArray *)chars {
  jint start = pos_;
  jint remaining = length_;
  while (pos_ < remaining) {
    {
      IOSCharArray *a__ = chars;
      jchar const *b__ = ((IOSCharArray *) nil_chk(a__))->buffer_;
      jchar const *e__ = b__ + a__->size_;
      while (b__ < e__) {
        jchar c = *b__++;
        if (IOSCharArray_Get(nil_chk(input_), pos_) == c) goto break_OUTER;
      }
    }
    pos_++;
  }
  break_OUTER: ;
  return pos_ > start ? OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, start, pos_ - start) : @"";
}

- (NSString *)consumeToAnySortedWithCharArray:(IOSCharArray *)chars {
  jint start = pos_;
  jint remaining = length_;
  IOSCharArray *val = input_;
  while (pos_ < remaining) {
    if (JavaUtilArrays_binarySearchWithCharArray_withChar_(chars, IOSCharArray_Get(nil_chk(val), pos_)) >= 0) break;
    pos_++;
  }
  return pos_ > start ? OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, start, pos_ - start) : @"";
}

- (NSString *)consumeData {
  jint start = pos_;
  jint remaining = length_;
  IOSCharArray *val = input_;
  while (pos_ < remaining) {
    jchar c = IOSCharArray_Get(nil_chk(val), pos_);
    if (c == '&' || c == '<' || c == OrgJsoupParserTokeniserState_nullChar) break;
    pos_++;
  }
  return pos_ > start ? OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, start, pos_ - start) : @"";
}

- (NSString *)consumeTagName {
  jint start = pos_;
  jint remaining = length_;
  IOSCharArray *val = input_;
  while (pos_ < remaining) {
    jchar c = IOSCharArray_Get(nil_chk(val), pos_);
    if (c == 0x0009 || c == 0x000a || c == 0x000d || c == 0x000c || c == ' ' || c == '/' || c == '>' || c == OrgJsoupParserTokeniserState_nullChar) break;
    pos_++;
  }
  return pos_ > start ? OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, start, pos_ - start) : @"";
}

- (NSString *)consumeToEnd {
  NSString *data = OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, pos_, length_ - pos_);
  pos_ = length_;
  return data;
}

- (NSString *)consumeLetterSequence {
  jint start = pos_;
  while (pos_ < length_) {
    jchar c = IOSCharArray_Get(nil_chk(input_), pos_);
    if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) pos_++;
    else break;
  }
  return OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, start, pos_ - start);
}

- (NSString *)consumeLetterThenDigitSequence {
  jint start = pos_;
  while (pos_ < length_) {
    jchar c = IOSCharArray_Get(nil_chk(input_), pos_);
    if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) pos_++;
    else break;
  }
  while (![self isEmpty]) {
    jchar c = IOSCharArray_Get(nil_chk(input_), pos_);
    if (c >= '0' && c <= '9') pos_++;
    else break;
  }
  return OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, start, pos_ - start);
}

- (NSString *)consumeHexSequence {
  jint start = pos_;
  while (pos_ < length_) {
    jchar c = IOSCharArray_Get(nil_chk(input_), pos_);
    if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')) pos_++;
    else break;
  }
  return OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, start, pos_ - start);
}

- (NSString *)consumeDigitSequence {
  jint start = pos_;
  while (pos_ < length_) {
    jchar c = IOSCharArray_Get(nil_chk(input_), pos_);
    if (c >= '0' && c <= '9') pos_++;
    else break;
  }
  return OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, start, pos_ - start);
}

- (jboolean)matchesWithChar:(jchar)c {
  return ![self isEmpty] && IOSCharArray_Get(nil_chk(input_), pos_) == c;
}

- (jboolean)matchesWithNSString:(NSString *)seq {
  jint scanLength = [((NSString *) nil_chk(seq)) java_length];
  if (scanLength > length_ - pos_) return false;
  for (jint offset = 0; offset < scanLength; offset++) if ([seq charAtWithInt:offset] != IOSCharArray_Get(nil_chk(input_), pos_ + offset)) return false;
  return true;
}

- (jboolean)matchesIgnoreCaseWithNSString:(NSString *)seq {
  jint scanLength = [((NSString *) nil_chk(seq)) java_length];
  if (scanLength > length_ - pos_) return false;
  for (jint offset = 0; offset < scanLength; offset++) {
    jchar upScan = JavaLangCharacter_toUpperCaseWithChar_([seq charAtWithInt:offset]);
    jchar upTarget = JavaLangCharacter_toUpperCaseWithChar_(IOSCharArray_Get(nil_chk(input_), pos_ + offset));
    if (upScan != upTarget) return false;
  }
  return true;
}

- (jboolean)matchesAnyWithCharArray:(IOSCharArray *)seq {
  if ([self isEmpty]) return false;
  jchar c = IOSCharArray_Get(nil_chk(input_), pos_);
  {
    IOSCharArray *a__ = seq;
    jchar const *b__ = ((IOSCharArray *) nil_chk(a__))->buffer_;
    jchar const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      jchar seek = *b__++;
      if (seek == c) return true;
    }
  }
  return false;
}

- (jboolean)matchesAnySortedWithCharArray:(IOSCharArray *)seq {
  return ![self isEmpty] && JavaUtilArrays_binarySearchWithCharArray_withChar_(seq, IOSCharArray_Get(nil_chk(input_), pos_)) >= 0;
}

- (jboolean)matchesLetter {
  if ([self isEmpty]) return false;
  jchar c = IOSCharArray_Get(nil_chk(input_), pos_);
  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
}

- (jboolean)matchesDigit {
  if ([self isEmpty]) return false;
  jchar c = IOSCharArray_Get(nil_chk(input_), pos_);
  return (c >= '0' && c <= '9');
}

- (jboolean)matchConsumeWithNSString:(NSString *)seq {
  if ([self matchesWithNSString:seq]) {
    pos_ += [((NSString *) nil_chk(seq)) java_length];
    return true;
  }
  else {
    return false;
  }
}

- (jboolean)matchConsumeIgnoreCaseWithNSString:(NSString *)seq {
  if ([self matchesIgnoreCaseWithNSString:seq]) {
    pos_ += [((NSString *) nil_chk(seq)) java_length];
    return true;
  }
  else {
    return false;
  }
}

- (jboolean)containsIgnoreCaseWithNSString:(NSString *)seq {
  NSString *loScan = [((NSString *) nil_chk(seq)) java_lowercaseStringWithJRELocale:JreLoadStatic(JavaUtilLocale, ENGLISH)];
  NSString *hiScan = [seq java_uppercaseStringWithJRELocale:JreLoadStatic(JavaUtilLocale, ENGLISH)];
  return ([self nextIndexOfWithJavaLangCharSequence:loScan] > -1) || ([self nextIndexOfWithJavaLangCharSequence:hiScan] > -1);
}

- (NSString *)description {
  return [NSString java_stringWithCharacters:input_ offset:pos_ length:length_ - pos_];
}

- (NSString *)cacheStringWithInt:(jint)start
                         withInt:(jint)count {
  return OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(self, start, count);
}

- (jboolean)rangeEqualsWithInt:(jint)start
                       withInt:(jint)count
                  withNSString:(NSString *)cached {
  if (count == [((NSString *) nil_chk(cached)) java_length]) {
    IOSCharArray *one = input_;
    jint i = start;
    jint j = 0;
    while (count-- != 0) {
      if (IOSCharArray_Get(nil_chk(one), i++) != [cached charAtWithInt:j++]) return false;
    }
    return true;
  }
  return false;
}

- (void)dealloc {
  RELEASE_(input_);
  RELEASE_(stringCache_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "I", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "C", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "C", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 1, 2, -1, -1, -1, -1 },
    { NULL, "I", 0x0, 1, 3, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, 4, 2, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, 4, 0, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x80, 5, 6, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x80, 7, 6, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 8, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 8, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 9, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x80, 10, 6, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 11, 6, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 12, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 13, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 14, 0, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 15, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, 16, 17, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 18, 19, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithNSString:);
  methods[1].selector = @selector(pos);
  methods[2].selector = @selector(isEmpty);
  methods[3].selector = @selector(current);
  methods[4].selector = @selector(consume);
  methods[5].selector = @selector(unconsume);
  methods[6].selector = @selector(advance);
  methods[7].selector = @selector(mark);
  methods[8].selector = @selector(rewindToMark);
  methods[9].selector = @selector(consumeAsString);
  methods[10].selector = @selector(nextIndexOfWithChar:);
  methods[11].selector = @selector(nextIndexOfWithJavaLangCharSequence:);
  methods[12].selector = @selector(consumeToWithChar:);
  methods[13].selector = @selector(consumeToWithNSString:);
  methods[14].selector = @selector(consumeToAnyWithCharArray:);
  methods[15].selector = @selector(consumeToAnySortedWithCharArray:);
  methods[16].selector = @selector(consumeData);
  methods[17].selector = @selector(consumeTagName);
  methods[18].selector = @selector(consumeToEnd);
  methods[19].selector = @selector(consumeLetterSequence);
  methods[20].selector = @selector(consumeLetterThenDigitSequence);
  methods[21].selector = @selector(consumeHexSequence);
  methods[22].selector = @selector(consumeDigitSequence);
  methods[23].selector = @selector(matchesWithChar:);
  methods[24].selector = @selector(matchesWithNSString:);
  methods[25].selector = @selector(matchesIgnoreCaseWithNSString:);
  methods[26].selector = @selector(matchesAnyWithCharArray:);
  methods[27].selector = @selector(matchesAnySortedWithCharArray:);
  methods[28].selector = @selector(matchesLetter);
  methods[29].selector = @selector(matchesDigit);
  methods[30].selector = @selector(matchConsumeWithNSString:);
  methods[31].selector = @selector(matchConsumeIgnoreCaseWithNSString:);
  methods[32].selector = @selector(containsIgnoreCaseWithNSString:);
  methods[33].selector = @selector(description);
  methods[34].selector = @selector(cacheStringWithInt:withInt:);
  methods[35].selector = @selector(rangeEqualsWithInt:withInt:withNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "EOF", "C", .constantValue.asUnichar = OrgJsoupParserCharacterReader_EOF, 0x18, -1, -1, -1, -1 },
    { "maxCacheLen", "I", .constantValue.asInt = OrgJsoupParserCharacterReader_maxCacheLen, 0x1a, -1, -1, -1, -1 },
    { "input_", "[C", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "length_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "pos_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mark_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "stringCache_", "[LNSString;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNSString;", "nextIndexOf", "C", "LJavaLangCharSequence;", "consumeTo", "consumeToAny", "[C", "consumeToAnySorted", "matches", "matchesIgnoreCase", "matchesAny", "matchesAnySorted", "matchConsume", "matchConsumeIgnoreCase", "containsIgnoreCase", "toString", "cacheString", "II", "rangeEquals", "IILNSString;" };
  static const J2ObjcClassInfo _OrgJsoupParserCharacterReader = { "CharacterReader", "org.jsoup.parser", ptrTable, methods, fields, 7, 0x10, 36, 7, -1, -1, -1, -1, -1 };
  return &_OrgJsoupParserCharacterReader;
}

@end

void OrgJsoupParserCharacterReader_initWithNSString_(OrgJsoupParserCharacterReader *self, NSString *input) {
  NSObject_init(self);
  self->pos_ = 0;
  self->mark_ = 0;
  JreStrongAssignAndConsume(&self->stringCache_, [IOSObjectArray newArrayWithLength:512 type:NSString_class_()]);
  OrgJsoupHelperValidate_notNullWithId_(input);
  JreStrongAssign(&self->input_, [((NSString *) nil_chk(input)) java_toCharArray]);
  self->length_ = ((IOSCharArray *) nil_chk(self->input_))->size_;
}

OrgJsoupParserCharacterReader *new_OrgJsoupParserCharacterReader_initWithNSString_(NSString *input) {
  J2OBJC_NEW_IMPL(OrgJsoupParserCharacterReader, initWithNSString_, input)
}

OrgJsoupParserCharacterReader *create_OrgJsoupParserCharacterReader_initWithNSString_(NSString *input) {
  J2OBJC_CREATE_IMPL(OrgJsoupParserCharacterReader, initWithNSString_, input)
}

NSString *OrgJsoupParserCharacterReader_cacheStringWithInt_withInt_(OrgJsoupParserCharacterReader *self, jint start, jint count) {
  IOSCharArray *val = self->input_;
  IOSObjectArray *cache = self->stringCache_;
  if (count > OrgJsoupParserCharacterReader_maxCacheLen) return [NSString java_stringWithCharacters:val offset:start length:count];
  jint hash_ = 0;
  jint offset = start;
  for (jint i = 0; i < count; i++) {
    hash_ = 31 * hash_ + IOSCharArray_Get(nil_chk(val), offset++);
  }
  jint index = hash_ & (((IOSObjectArray *) nil_chk(cache))->size_ - 1);
  NSString *cached = IOSObjectArray_Get(cache, index);
  if (cached == nil) {
    cached = [NSString java_stringWithCharacters:val offset:start length:count];
    IOSObjectArray_Set(cache, index, cached);
  }
  else {
    if ([self rangeEqualsWithInt:start withInt:count withNSString:cached]) {
      return cached;
    }
    else {
      cached = [NSString java_stringWithCharacters:val offset:start length:count];
    }
  }
  return cached;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgJsoupParserCharacterReader)
